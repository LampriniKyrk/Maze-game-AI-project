/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package maze;

import com.sun.corba.se.impl.orbutil.ORBConstants;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.GridBagLayout;
import java.awt.GridLayout;
import java.awt.Image;
import java.awt.Rectangle;
import java.awt.Shape;
import static java.awt.event.KeyEvent.*;
import java.awt.image.ImageObserver;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.text.AttributedCharacterIterator;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Random;
import java.util.logging.Level;
import java.util.logging.Logger;
import javafx.scene.input.KeyCode;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import static javax.swing.JOptionPane.YES_NO_OPTION;
import javax.swing.JPanel;
import maze.gameItems.GameItem;

/**
 *
 * @author ASUS
 */
public class GUI extends javax.swing.JFrame {
     
    private Cell [][] maze; //the maze as it gets generatated from the MazeGenerator Object
    private MazeGenerator mgen ; // the maze generator
    private javax.swing.JPanel[][] cells ; // the panels that belong to the maze's grid
    private javax.swing.JLabel[][] cellsLabels;
    //Coordinates for each panel [cells] to mach the [maze] coordinates
    static HashMap<JPanel,Coordinates> cellsCoordinates;
    private MyMouseListener ml;
    private GameRules grules; //game rules obj
    private boolean turn ; //true: player turn  , false: enemies turn
    private boolean game; //true: still playing, false: game over
     
    /**
     * Creates new form GUI
     */
    public GUI() {
        Coordinates []enemiesCoordinates;
        Coordinates playerCoordinates;
        game = true;
        ml = new MyMouseListener();
        cellsCoordinates = new HashMap<>();
        initComponents();
        
        getContentPane().setBackground(new java.awt.Color(52,98,0));
        setLocationRelativeTo(null);
        setResizable(false);
        initMaze(false);
        //initialize player and enemy positions
        playerCoordinates = initializePlayerPosition();
        enemiesCoordinates= initializeEnemiesPosition(1);
        
        //initialize rules
        grules = new GameRules(maze, playerCoordinates, 1, enemiesCoordinates,false);
        initGame();
        
        
        
    }

    /**
     * This method is called from within the constructor to initialise the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        wholeGameArea = new javax.swing.JPanel();
        PlayingArea = new javax.swing.JPanel();
        speedLabel = new javax.swing.JLabel();
        turnLabel = new javax.swing.JLabel();
        itemTextLabel = new javax.swing.JLabel();
        itemIconLabel = new javax.swing.JLabel();
        menu = new javax.swing.JMenuBar();
        FileMenu = new javax.swing.JMenu();
        EditMenu = new javax.swing.JMenu();
        jMenu3 = new javax.swing.JMenu();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("maze");
        setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                formKeyReleased(evt);
            }
        });

        wholeGameArea.setBackground(new java.awt.Color(153, 153, 255));

        PlayingArea.setBackground(new java.awt.Color(0, 0, 0));
        PlayingArea.setMinimumSize(new java.awt.Dimension(640, 320));
        PlayingArea.setPreferredSize(new java.awt.Dimension(640, 320));

        javax.swing.GroupLayout PlayingAreaLayout = new javax.swing.GroupLayout(PlayingArea);
        PlayingArea.setLayout(PlayingAreaLayout);
        PlayingAreaLayout.setHorizontalGroup(
            PlayingAreaLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 640, Short.MAX_VALUE)
        );
        PlayingAreaLayout.setVerticalGroup(
            PlayingAreaLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 383, Short.MAX_VALUE)
        );

        speedLabel.setText("speed:");

        turnLabel.setText("turn:");

        itemTextLabel.setText("item:");

        javax.swing.GroupLayout wholeGameAreaLayout = new javax.swing.GroupLayout(wholeGameArea);
        wholeGameArea.setLayout(wholeGameAreaLayout);
        wholeGameAreaLayout.setHorizontalGroup(
            wholeGameAreaLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, wholeGameAreaLayout.createSequentialGroup()
                .addGap(40, 40, 40)
                .addComponent(PlayingArea, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(wholeGameAreaLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(wholeGameAreaLayout.createSequentialGroup()
                        .addComponent(itemTextLabel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 30, Short.MAX_VALUE)
                        .addComponent(itemIconLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 39, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(51, 51, 51))
                    .addGroup(wholeGameAreaLayout.createSequentialGroup()
                        .addComponent(turnLabel)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, wholeGameAreaLayout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(speedLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 73, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(71, 71, 71))
        );
        wholeGameAreaLayout.setVerticalGroup(
            wholeGameAreaLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(wholeGameAreaLayout.createSequentialGroup()
                .addGap(23, 23, 23)
                .addComponent(speedLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 21, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(wholeGameAreaLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(wholeGameAreaLayout.createSequentialGroup()
                        .addComponent(PlayingArea, javax.swing.GroupLayout.DEFAULT_SIZE, 383, Short.MAX_VALUE)
                        .addGap(64, 64, 64))
                    .addGroup(wholeGameAreaLayout.createSequentialGroup()
                        .addComponent(turnLabel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(wholeGameAreaLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(itemTextLabel)
                            .addComponent(itemIconLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 14, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
        );

        menu.setBackground(new java.awt.Color(102, 102, 255));
        menu.setForeground(new java.awt.Color(51, 0, 204));

        FileMenu.setText("New Game");
        FileMenu.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                FileMenuMouseClicked(evt);
            }
        });
        menu.add(FileMenu);

        EditMenu.setText("Edit");
        menu.add(EditMenu);

        jMenu3.setText("About");
        menu.add(jMenu3);

        setJMenuBar(menu);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(wholeGameArea, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(wholeGameArea, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * main function for the game. As long as the player keeps pressing the arrow keys to move and the space button to use 
     * items and the game has not ended , the enemy AI function is called and the game continues. All representative changes
     * in the UI are shown each turn. 
     * @param evt 
     */
    private void formKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_formKeyReleased
        
        //if it is the players turn then it is allowed to move the avatar
        if(turn && game && !grules.mainPlayer.stunned()){
            turnLabel.setText("Turn: Player");
            boolean successFlag; //indicades if the move was successful or not
            if (evt.getKeyCode()== VK_UP){ //UP ARROW KEY
                int y = grules.mainPlayer.getPositionY();
                int x = grules.mainPlayer.getPositionX();
                successFlag = grules.movePlayer(new Coordinates(x, y-1));
                //if the move was successfull update GUI 
                if(successFlag){
                    updateGui(new Coordinates(x, y));
                    int speed = grules.mainPlayer.getSpeed();
                    //only if the player has no more movement points left the turn changes
                    if(speed==0)
                        turn = false;

                }
            }
            if (evt.getKeyCode()== VK_DOWN){ //DOWN ARROW KEY
                int y = grules.mainPlayer.getPositionY();
                int x = grules.mainPlayer.getPositionX();
                successFlag = grules.movePlayer(new Coordinates(x, y+1));

                if(successFlag){
                    updateGui(new Coordinates(x, y));
                    int speed = grules.mainPlayer.getSpeed();
                    if(speed==0)
                        turn = false;
                }
            }
            if (evt.getKeyCode()== VK_RIGHT){ // RIGHT ARROW KEY_player moves one tile on the right
                int y = grules.mainPlayer.getPositionY();
                int x = grules.mainPlayer.getPositionX();
                successFlag = grules.movePlayer(new Coordinates(x+1, y));
                //if the move is not obstructed by a wall
                if(successFlag){
                    updateGui(new Coordinates(x, y));
                    //get the number of actions the player has left
                    int speed = grules.mainPlayer.getSpeed();
                    if(speed==0)
                        turn = false;
                }
            }
            if (evt.getKeyCode()== VK_LEFT){ //LEFT ARROW KEY _player moves one tile on the left
                int y = grules.mainPlayer.getPositionY();
                int x = grules.mainPlayer.getPositionX();
                successFlag = grules.movePlayer(new Coordinates(x-1, y));

                if(successFlag){
                    updateGui(new Coordinates(x, y));
                    //get the number of actions the player has left
                    int speed = grules.mainPlayer.getSpeed();
                    if(speed==0)
                        turn = false;
                }
                
            }
            //USE ITEM ACTION BY PRESSING SPACE
            if(evt.getKeyCode()== VK_SPACE){
                //USE ITEM ON SLOT
                if(grules.mainPlayer.getItem()!=null){
                    GameItem item = grules.mainPlayer.getItem();
                    //System.out.println("using item"+item.getName());
                    
                    int choice = grules.mainPlayer.enableItem();
                    //depending on the item the result will differ
                    switch(choice){
                        case 1: //book
                            if(grules.mainPlayer.getUsedItem().canBeUsed(grules.enemy[0], grules.mainPlayer, false, maze)){
                                // ON SUCCESS ENEMY WILL LOSE HIS ITEM
                                //check if hit
                                boolean success = grules.mainPlayer.getUsedItem().succeeded(1);
                                if(grules.enemy[0].getItem()!=null && success){
                                    grules.enemy[0].setItemToNull(); //might not work 
                                }
                                else{
                                    JOptionPane.showMessageDialog(rootPane, "Item failed");
                                }
                                
                            }
                            //if the item cannot be used it just dissappears from the inventory
                            grules.mainPlayer.setItemToNull();
                            grules.mainPlayer.setUsedItemToNull();
                            break;
                        case 2: //net
                            if(grules.mainPlayer.getUsedItem().canBeUsed(grules.enemy[0], grules.mainPlayer, false, maze)){
                                //on success stun enemy- enemy will lose his turn
                                boolean success = grules.mainPlayer.getUsedItem().succeeded(1);
                                if(success)
                                    grules.enemy[0].setSpeed(0);
                                else
                                    JOptionPane.showMessageDialog(rootPane, "Item failed");
                   
                            }
                            //if the item cannot be used it just dissappears from the inventory
                            grules.mainPlayer.setItemToNull();
                            grules.mainPlayer.setUsedItemToNull();
                            break;
                        case 3://running shoes
                            
                            break;
                        case 4: //hoodie
                            boolean success = grules.mainPlayer.getUsedItem().succeeded(1);
                            if(success){
                                //sent boolean into gamerules that indicates to use old player coordinates for agentsAI
                                grules.setPlayerHidden(true);
                                grules.setDummyPlayer(grules.mainPlayer); 
                            }
                            else
                                JOptionPane.showMessageDialog(rootPane, "Item failed"); 
                            
                            break;
                        case 5: //sandwich
                            grules.mainPlayer.setChanceToEscape(true);
                            break;
                    }
                    //lose an action when u use an item
                    grules.mainPlayer.setSpeed(grules.mainPlayer.getSpeed()-1);
                    if(grules.mainPlayer.getSpeed()==0)
                        turn = false;  
                }
            }
            //________________________________
            //___AGENTS TURN STARTS NOW ______
            //--------------------------------
            if(grules.mainPlayer.getSpeed()==0 || turn == false){
                grules.mainPlayer.setStunned(false);
                
                boolean gameStops = false;
                turn = false;
                
                //check if the agent won_CASE: player moved on enemy's tile
                //player has sandwich effect meaning he has a chance to escape
                if(grules.agentWon() && grules.mainPlayer.chanceToEscape()){
                    //if the player didn't manage to escape end the game
                    if(!grules.mainPlayer.getUsedItem().escaped()){
                         game = false;
                         gameStops = true;
                        //show a message saying you lost 
                         JOptionPane.showMessageDialog(rootPane, "YOU GOT CAPTURED");
                    }
                    //if the player did escape give him a speed boost
                    else{
                        grules.mainPlayer.setSpeed(3);
                    }
                }
                
                
                //now the player stops if hes using an item
                if(grules.mainPlayer.getUsedItem()!=null){
                    //reduce duration by one
                    grules.mainPlayer.reduceItemDuration();
                }
                //if duration is 0 item must free the used item slot
                if(grules.mainPlayer.getItemDuration()==0){
                    
                    if(grules.mainPlayer.chanceToEscape()) //in this case the item sandwitch is workin
                        grules.mainPlayer.setChanceToEscape(false);
                    //if the item used was the hoodie (invisibility) make the appropriate changes so it doesn;t work any more
                    if(grules.playerIsHidden()){
                        grules.setPlayerHidden(false);
                    }
                    grules.mainPlayer.setUsedItemToNull();
                    itemTextLabel.setText("Item: ");
                    
                }
                else{
                    //re apply the item's effect
                    if(grules.mainPlayer.getUsedItem()!=null){
                        if(grules.mainPlayer.getUsedItem().getName().equals("running shoes"))
                            grules.mainPlayer.setSpeed(3); 
                        if(grules.mainPlayer.getUsedItem().getName().equals("sport shoes"))
                            grules.mainPlayer.setSpeed(2);
                    }
                    
                }

                
                
                //if the enemy was not stunned
                if(grules.enemy[0].getSpeed()!=0 && game){
                    int tmpspd = grules.enemy[0].getSpeed();
                    for (int i = 0; i < tmpspd; i++) {
                        Coordinates oldPos = grules.enemy[0].getCoordinates();
                        turnLabel.setText("Turn: PC");
                        //call AI function to move ENEMIES
                        grules.EnemyAI();
                        updateGui(oldPos);
                        
                    }
                    turnLabel.setText("Turn: Player");
                    
                }

                //update gui
                for (Enemy enemy : grules.enemy) {
                    updateGui(new Coordinates(enemy.getPositionX(), enemy.getPositionY()));
                    //speed must change acoording to items in use
                    if(enemy.getUsedItem()!=null){
                        if(enemy.getUsedItem().equals("running shoes")) enemy.setSpeed(3);
                        else if (enemy.getUsedItem().equals("sport shoes")) enemy.setSpeed(2);
                    }
                    else enemy.setSpeed(1);
                    
                }
                
                turn = true;

                
                //********IF GAME IS ABOUT TO END*********//
                //check if the player escaped. in case he was caught and had the sandwitch item enabled
                //if the player has successfully escaped give him a +2 speed boost
                gameStops = false;
                //if the agent is on the same tile as the player
                //and the player has a chance to escape
                if(grules.agentWon()){
                        if( grules.mainPlayer.chanceToEscape()){
                            //if the player managed to escape
                            if(grules.mainPlayer.getUsedItem().escaped()){
                                System.out.println("ESCAPED");
                                grules.mainPlayer.setSpeed(3); //maybe 2 is too little
                            }
                        }
                        else{
                            gameStops = true; //if he didn't manage to escape the game will stop
                            //and the agent will be the winner
                        }
                }
                

                
                //check if the game has ended
                //if pc won the player and the agent will be on the same space
                //if game is true means that the player may have moved on the agent and therefore the game has already ended
                if(grules.agentWon() &&  gameStops){
                    game = false;
                    //show a message saying you lost 
                    JOptionPane.showMessageDialog(rootPane, "YOU GOT CAPTURED");
                }
                //if the player has won , he will be on an end tile
                if(grules.playerWon()){
                    game = false;
                    //show a message saying you won!
                    JOptionPane.showMessageDialog(rootPane, "YOU ESCAPED!!!");
                }
                
                //reset the player's basic movement action
                if(grules.mainPlayer.getSpeed()==0)
                    grules.mainPlayer.setSpeed(1);
            }
            
        }
        
    }//GEN-LAST:event_formKeyReleased
    /**
     * Function that implements the new game feature. 
     * @param evt 
     */
    private void FileMenuMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_FileMenuMouseClicked
        // TODO add your handling code here:
        int n = JOptionPane.showConfirmDialog(rootPane, "Are you sure you want to start an new game?","New Game",YES_NO_OPTION);
        System.out.println("N is "+ n);
        if(n==0){//yes option
            maze = null;
            if(wholeGameArea!=null){
                wholeGameArea.setVisible(false);
                remove(wholeGameArea);
            }
            buildMainPanel();
            
             
            Coordinates []enemiesCoordinates;
            Coordinates playerCoordinates;
            game = true;
            turn = true;
            ml = new MyMouseListener();
            cellsCoordinates = new HashMap<>();

            getContentPane().setBackground(new java.awt.Color(52,98,0));
            setLocationRelativeTo(null);
            setResizable(false);
            
            initMaze(false);
            //initialize player and enemy positions
            playerCoordinates = initializePlayerPosition();
            enemiesCoordinates = initializeEnemiesPosition(1);
            updateGui(playerCoordinates);
            updateGui(enemiesCoordinates[0]);

            //initialize rules
            grules = new GameRules(maze, playerCoordinates, 1, enemiesCoordinates,false);
            initGame();
        }
    }//GEN-LAST:event_FileMenuMouseClicked

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new GUI().setVisible(true);
            }
        });
    }
    /**
     * initialises maze shown on gui
     * @param loadfromFile  : true if the maze is loaded from file, else false and is generated by the maze generator
     */
    private void initMaze(boolean loadfromFile){
        //if the maze was loaded from the file
        if (loadfromFile){
            try {
                FileInputStream fin = new FileInputStream("maze.ser");
                ObjectInputStream oin = new ObjectInputStream(fin);

                //read maze from file
                maze = (Cell[][]) oin.readObject();
            } catch (FileNotFoundException ex) {
                Logger.getLogger(GUI.class.getName()).log(Level.SEVERE, null, ex);
            } catch (IOException ex) {
                Logger.getLogger(GUI.class.getName()).log(Level.SEVERE, null, ex);
            } catch (ClassNotFoundException ex) {
                Logger.getLogger(GUI.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
        else{ //Generate a MAZE
            mgen = new MazeGenerator(20, 10, 40, 50);
            mgen.generateMaze();
            maze = mgen.getMaze();
        }
        //when the maze was successfully created or loaded
        //building it graphical comences
        cells = new JPanel[10][20];
        cellsLabels= new JLabel[10][20];
        //set layout
        GridLayout gridbig = new GridLayout(10, 20, 1, 1);
        PlayingArea.setLayout(gridbig);
        
        for (int i = 0; i < 10; i++) { 
            for (int j = 0; j < 20; j++) {
                cells[i][j] = new JPanel();
                //keep its coordinates in the hashmap
                cellsCoordinates.put(cells[i][j], new Coordinates(j, i));
                //add listener to the cell
                cells[i][j].addMouseListener(ml);
                //construct the visible walls
                JPanel []cellWall = new JPanel[5];
                cells[i][j].setLayout(new BorderLayout());
                //each cell contains 5 panels , 4 panels indicate the walls and the 5th th room/road
                for (int k = 0; k < cellWall.length; k++) {
                    cellWall[k] = new JPanel();
                    cellWall[k].setBackground(Color.white);
                    cellWall[k].setVisible(false);
                    if(k==0)cells[i][j].add(cellWall[k],BorderLayout.NORTH);
                    if(k==1)cells[i][j].add(cellWall[k],BorderLayout.EAST);
                    if(k==2)cells[i][j].add(cellWall[k],BorderLayout.SOUTH);
                    if(k==3)cells[i][j].add(cellWall[k],BorderLayout.WEST);
                    if(k==4)cells[i][j].add(cellWall[k],BorderLayout.CENTER);
                }
                //get cell's walls and paint them black
                String tmp = maze[i][j].getwalls();
                String[]walls = tmp.split(" ");
                cellWall[4].setVisible(true);
                for (String wall : walls) {
                    if(wall.equals("north")){
                        cellWall[0].setBackground(Color.black); 
                        cellWall[0].setPreferredSize(new Dimension(30, 3));
                        cellWall[0].setVisible(true);
                    }
                    if(wall.equals("east")){
                        cellWall[1].setBackground(Color.black);
                        cellWall[1].setPreferredSize(new Dimension(3, 36));
                        cellWall[1].setVisible(true);
                    }
                    if(wall.equals("south")){
                        cellWall[2].setBackground(Color.black);
                        cellWall[2].setPreferredSize(new Dimension(30, 3));
                        cellWall[2].setVisible(true);
                    }
                    if(wall.equals("west")){
                        cellWall[3].setBackground(Color.black);
                        cellWall[3].setPreferredSize(new Dimension(3, 36));
                        cellWall[3].setVisible(true);
                        
                    }
                }
                
                cells[i][j].setBackground(Color.WHITE);
                cells[i][j].setVisible(true);
                
                PlayingArea.add(cells[i][j]);
            }
            
        }
    }
    
    
    /**
     * Sets the player on a random cell on the first column of the maze
     * @return the coordinated of the player
     */
    private Coordinates initializePlayerPosition(){
        
        //player position will be a randomly selected row  on column 0
        Random rng = new Random();
        int posY = rng.nextInt(10);
        
        Component[] walls =  cells[posY][0].getComponents();
        //temporarily set room <walls[4] > blue to indicate the player
        //must become image later
        walls[4].setBackground(Color.blue);
        walls[4].setVisible(true);
        maze[posY][0].setPlayerOnCell(true);
        return  (new Coordinates(0, posY));
    }
    
    private Coordinates[] initializeEnemiesPosition(int numOfEnemies){
        Coordinates[] enemyCoordinates = new Coordinates[numOfEnemies];
        //totally random position on Y axis
        //random position on X axis (1/3 onwards)
        /*Random rng = new Random();
        for (int i = 0; i < numOfEnemies; i++) {
            
            int posY = rng.nextInt(10);
            //System.out.println("position of init enemy y is "+posY);
            int posX = rng.nextInt(20/3)+ 20/3;
            //while spawn point the same as another anemy character do find another point
            while(maze[posY][posX].isEnemyOnCell()){
                posY = rng.nextInt(10);
                posX = rng.nextInt(20/3)+ 20/3;
            }
            enemyCoordinates[i] = new Coordinates(posX, posY);
            //set enemy on specific tile/cell
            maze[posY][posX].setEnemyOnCell(true);

            Component[] walls =  cells[posY][posX].getComponents();
            //temporarily set room <walls[4] > red to indicate the enemy
            //must become image later
            if(walls[4].getBackground().equals(Color.white)) walls[4].setBackground(Color.red);  
        } */
        
        enemyCoordinates[0] = new Coordinates(9, 8);
        maze[8][9].setEnemyOnCell(true);
        Component[]walls = cells[8][9].getComponents();
        //temporarily set room <walls[4] > red to indicate the enemy
        //must become image later
        if(walls[4].getBackground().equals(Color.white)) walls[4].setBackground(Color.red);
        
        return enemyCoordinates;
    }
    
    //INITIALIZE GAME
    private void initGame(){
        //player plays always first
        //players speed
        grules.enemy[0].setSpeed(1);
        grules.mainPlayer.setSpeed(1);
        speedLabel.setText("Moves Left : 1");
        turn = true;  
        
        //paint end tiles
        Coordinates []endCoordinates = new Coordinates[4];       
        endCoordinates = grules.getEndTilesCoordinates();
        
        for (Coordinates endCoordinate : endCoordinates) {
            Component[] walls =  cells[endCoordinate.y][endCoordinate.x].getComponents();
            //temporarily set room <walls[4] > 
            //must become image later
            if(walls[4].getBackground().equals(Color.white)) walls[4].setBackground(Color.LIGHT_GRAY);
        }
        
        //paint items
        Coordinates []itemCoordinates = new Coordinates[6];
        itemCoordinates = grules.getItemCoordinates();
        
        //find all items in play
        ArrayList<Coordinates> items = new ArrayList<>();
        //HashMap<String,Coordinates> itemNames = new HashMap<>();
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < 20; j++) {
                if (maze[i][j].getItem()!=null){
                    System.out.println("Item in : "+ i + " - "+j +" ");
                    
                }
                if(maze[i][j].isPlayerOnCell()) System.out.println("Player on cell :"+i+" "+j);
                if(maze[i][j].isEnemyOnCell()) System.out.println("Agent on cell :"+i+" "+j);
                
            }
            
        }
        
        for (Coordinates item : itemCoordinates) {
            Component[] walls =  cells[item.y][item.x].getComponents();
            //temporarily set room <walls[4] > 
            //must become image later
            switch(maze[item.y][item.x].getItem().getName()){
                case "net":
                    if(walls[4].getBackground().equals(Color.white)) walls[4].setBackground(Color.GREEN);
                    break;
                case "sport shoes":
                    if(walls[4].getBackground().equals(Color.white)) walls[4].setBackground(Color.CYAN);
                    break;
                case "running shoes":
                    if(walls[4].getBackground().equals(Color.white)) walls[4].setBackground(Color.PINK);
                    break;
                case "book":
                    if(walls[4].getBackground().equals(Color.white)) walls[4].setBackground(Color.ORANGE);
                    break;
                case "sandwich":
                    if(walls[4].getBackground().equals(Color.white)) walls[4].setBackground(Color.MAGENTA);
                    break;
                case "hoodie":
                    if(walls[4].getBackground().equals(Color.white)) walls[4].setBackground(Color.BLACK);
                    break;
                default:
                    if(walls[4].getBackground().equals(Color.white)) walls[4].setBackground(Color.GREEN);
                    break;
            }
            

        }
   
    }
    
    //UPDATES GUI
    private void updateGui(Coordinates oldPos){
        //make old position white
        Component[] walls ;
        walls =  cells[oldPos.y][oldPos.x].getComponents();
        if(!walls[4].getBackground().equals(Color.white)) walls[4].setBackground(Color.white);
        
        //update enemy position
        walls =  cells[grules.enemy[0].getPositionY()][grules.enemy[0].getPositionX()].getComponents();
        //temporarily set room <walls[4] > red to indicate the enemy
        if(grules.enemy[0].getUsedItem()!=null){
            if(grules.enemy[0].getUsedItem().getName().equals("hoodie"))
                walls[4].setBackground(Color.white);
            else
                walls[4].setBackground(Color.red);    
        }
        else
            walls[4].setBackground(Color.red);        
        
        //update player position
        walls =  cells[grules.mainPlayer.getPositionY()][grules.mainPlayer.getPositionX()].getComponents();
        if(!walls[4].getBackground().equals(Color.blue)) walls[4].setBackground(Color.blue);
        
        //update Labels
        speedLabel.setText("Moves Left : "+grules.mainPlayer.getSpeed());
        if(grules.mainPlayer.getItem()!= null)
            itemTextLabel.setText("Item : "+grules.mainPlayer.getItem().getName());
        
        
    }
    
    //copied from automatically generated code in order to make the new game button work.
    public void buildMainPanel(){
        wholeGameArea = new javax.swing.JPanel();
        PlayingArea = new javax.swing.JPanel();
        speedLabel = new javax.swing.JLabel();
        turnLabel = new javax.swing.JLabel();
        itemTextLabel = new javax.swing.JLabel();
        itemIconLabel = new javax.swing.JLabel();
        menu = new javax.swing.JMenuBar();
        FileMenu = new javax.swing.JMenu();
        EditMenu = new javax.swing.JMenu();
        jMenu3 = new javax.swing.JMenu();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("maze");
        setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        
        wholeGameArea.setBackground(new java.awt.Color(153, 153, 255));

        PlayingArea.setBackground(new java.awt.Color(0, 0, 0));
        PlayingArea.setMinimumSize(new java.awt.Dimension(640, 320));
        PlayingArea.setPreferredSize(new java.awt.Dimension(640, 320));

        javax.swing.GroupLayout PlayingAreaLayout = new javax.swing.GroupLayout(PlayingArea);
        PlayingArea.setLayout(PlayingAreaLayout);
        PlayingAreaLayout.setHorizontalGroup(
            PlayingAreaLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 640, Short.MAX_VALUE)
        );
        PlayingAreaLayout.setVerticalGroup(
            PlayingAreaLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 383, Short.MAX_VALUE)
        );

        speedLabel.setText("speed:");

        turnLabel.setText("turn:");

        itemTextLabel.setText("item:");

        javax.swing.GroupLayout wholeGameAreaLayout = new javax.swing.GroupLayout(wholeGameArea);
        wholeGameArea.setLayout(wholeGameAreaLayout);
        wholeGameAreaLayout.setHorizontalGroup(
            wholeGameAreaLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, wholeGameAreaLayout.createSequentialGroup()
                .addGap(40, 40, 40)
                .addComponent(PlayingArea, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(wholeGameAreaLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(wholeGameAreaLayout.createSequentialGroup()
                        .addComponent(itemTextLabel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 30, Short.MAX_VALUE)
                        .addComponent(itemIconLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 39, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(51, 51, 51))
                    .addGroup(wholeGameAreaLayout.createSequentialGroup()
                        .addComponent(turnLabel)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, wholeGameAreaLayout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(speedLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 73, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(71, 71, 71))
        );
        wholeGameAreaLayout.setVerticalGroup(
            wholeGameAreaLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(wholeGameAreaLayout.createSequentialGroup()
                .addGap(23, 23, 23)
                .addComponent(speedLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 21, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(wholeGameAreaLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(wholeGameAreaLayout.createSequentialGroup()
                        .addComponent(PlayingArea, javax.swing.GroupLayout.DEFAULT_SIZE, 383, Short.MAX_VALUE)
                        .addGap(64, 64, 64))
                    .addGroup(wholeGameAreaLayout.createSequentialGroup()
                        .addComponent(turnLabel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(wholeGameAreaLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(itemTextLabel)
                            .addComponent(itemIconLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 14, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
        );

        menu.setBackground(new java.awt.Color(102, 102, 255));
        menu.setForeground(new java.awt.Color(51, 0, 204));

        FileMenu.setText("New Game");
        FileMenu.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                FileMenuMouseClicked(evt);
            }
        });
        menu.add(FileMenu);

        EditMenu.setText("Edit");
        menu.add(EditMenu);

        jMenu3.setText("About");
        menu.add(jMenu3);

        setJMenuBar(menu);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(wholeGameArea, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(wholeGameArea, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        pack();
    }
    

    
    
   

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenu EditMenu;
    private javax.swing.JMenu FileMenu;
    private javax.swing.JPanel PlayingArea;
    private javax.swing.JLabel itemIconLabel;
    private javax.swing.JLabel itemTextLabel;
    private javax.swing.JMenu jMenu3;
    private javax.swing.JMenuBar menu;
    private javax.swing.JLabel speedLabel;
    private javax.swing.JLabel turnLabel;
    private javax.swing.JPanel wholeGameArea;
    // End of variables declaration//GEN-END:variables
}
